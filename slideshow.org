#+Title: RoR Experience in Elixir
#+Author: Scott Smith (OldFartDeveloper)
#+Email: scottnelsonsmith@gmail.com

* Introduction

Tonight:

  - Introduce *Elixir* / *Phoenix*

  - Build a *Phoenix* web app with authentication

  - Discuss development environment

* Elixir / Phoenix

  - Elixir :: A syntactically-rich functional language that transpiles to Erlang,
              a mature ultra-reliable language and library that's been developed
              ove the last 30 years.
  - Phoenix :: A web framework implemented in Elixir and patterned liked Rails.

** Elixir

    - Syntax is not Ruby but feels like it.
    - Like Ruby, has powerful metaprogramming capability.

** Phoenix

  - Patterned after Rails
    - Model/View/Controller
    - Migrations
    - Scaffolding
    - Console

** Erlang

Powerful


*  Web App w/ Authentication

** Requirements

  - Users can post their thoughts ("pheets") up to 255 chars

  - Basic authentication (user/password)

** Process

Use =mix=

  - Build 2 models: =User= and =Pheets=

  - Use *Plug* to build basic auth

  - Build out other *MVC* components using =mix=

*** Make a New Project

#+BEGIN_SRC bash
mix phoenix.new phitter
#+END_SRC

To question: "Install mix dependencies? [Yn]", answer 'n'

To question: "Install brunch.io dependencies? [Yn]", answer 'Y'

Wait several seconds for =npm install=.

*** Phoenix Upgrade Instructions

[[https://gist.github.com/chrismccord/57805158f463d3369103][Phoenix Upgrade Instructions]]

In =mix.exe=, bump =phoenix= and =phoenix_html= versions:

#+BEGIN_SRC elixir
def deps do
  [{:phoenix, "~> 0.14"},
  {:phoenix_html, "~> 1.1"}, ...
end
#+END_SRC

Do

#+BEGIN_SRC
cd phitter
mix deps.get
#+END_SRC

*** Phoenix Upgrade Instructions (cont)

In the controller, remove =plug :action=

#+BEGIN_SRC
defmodule Phitter.PageController do
  use Phitter.Web, :controller

#  plug :action  <== HERE!

  def index(conn, _params) do
    render conn, "index.html"
  end
end
#+END_SRC

*** Phoenix Upgrade Instructions (cont)

Rename the default template:

#+BEGIN_SRC bash
mv web/templates/layout/application.html.eex web/templates/layout/app.html.eex
#+END_SRC

*** Now You Should See the Install Page

#+BEGIN_SRC bash
mix phoenix.server
#+END_SRC

It will compile everything and start the server.

Browse =http://localhost:4000=

You should see [[file:./phitter/web/static/images/Hello_Phoenix.jpg][the initial landing page]]

*** Our Replacement Landing Page

Edit App Layout - Body

#+BEGIN_SRC html
<!-- phitter/web/templates/layout/app.html.eex -->
...
  <body>
    <div class="container">
      <p class="alert alert-info"><%= get_flash(@conn, :info) %></p>
      <p class="alert alert-danger"><%= get_flash(@conn, :error) %></p>
    </div>
    <div class="text-center">
      <h1>Phitter</h1>
    </div>
    <div class="container">
      <%= @inner %>
    </div> <!-- /container -->
    <script src="<%= static_path(@conn, "/js/app.js") %>"></script>
    <script>require("web/static/js/app")</script>
  </body>
</html>
#+END_SRC

*** Use =mix= to Create a User Model =user.ex=

#+BEGIN_SRC bash
$ mix phoenix.gen.model User users username encrypted_password
#+END_SRC

Here's what =mix= Generates

#+BEGIN_SRC elixir
defmodule Phitter.User do
  use Phitter.Web, :model

  schema "users" do
    field :username, :string
    field :encrypted_password, :string

    timestamps
  end

  @required_fields ~w(username encrypted_password)
  @optional_fields ~w()

  @doc """
  Creates a changeset based on the =model= and =params=.

  If =params= are nil, an invalid changeset is returned
  with no validation performed.
  """
  def changeset(model, params \\ :empty) do
    model
    |> cast(params, @required_fields, @optional_fields)
  end
end
#+END_SRC

*** Customize =user.ex=

  - Make =password= and =password_confirmation= fields virtual attributes.

  - Implement field-required validation

#+BEGIN_SRC elixir
  schema "users" do
    field :username, :string
    field :encrypted_password, :string
    field :password, :string, virtual: true               # <== NEW
    field :password_confirmation, :string, virtual: true  # <== NEW
    timestamps
  end

  @required_fields ~w(username password password_confirmation) # <== Changed
  @optional_fields ~w()
#+END_SRC

*** Create Changeset for =user.ex=

#+BEGIN_SRC elixir
  @doc """
  Creates a changeset based on the =model= and =params=.

  If =params= are nil, an invalid changeset is returned
  with no validation performed.
  """
  def changeset(model, params \\ nil) do
    model
    |> cast(params, @required_fields, @optional_fields)
    |> validate_unique(:username, on: Phitter.Repo, downcase: true) # <== NEW
    |> validate_length(:password, min: 1)                           # <== NEW
    |> validate_length(:password_confirmation, min: 1)              # <== NEW
    |> validate_confirmation(:password)                             # <== NEW
  end
#+END_SRC

*** Add User to =web.ex=

#+BEGIN_SRC elixir
### phitter/web/web.ex
  def controller do
    quote do
      use Phoenix.Controller

      alias Phitter.User    # <== NEW

      # Alias the data repository and import query/model functions
      alias Phitter.Repo
      import Ecto.Model
      import Ecto.Query, only: [from: 2]
      import Phitter.Plug.Authenticate  # ??? This wasn't generated; should I leave it out?

      # Import URL helpers from the router
      import Phitter.Router.Helpers
    end
  end
#+END_SRC

*** Registration Components

  - Controller

  - View

  - Template

*** Add Registration Controller

#+BEGIN_SRC elixir
### phitter/web/controllers/registration_controller.ex
defmodule Phitter.RegistrationController do
  use Phitter.Web, :controller

  def new(conn, _params) do
    changeset = User.changeset(%User{})
    render conn, changeset: changeset
  end

end
#+END_SRC

*** Add Registration View

#+BEGIN_SRC elixir
### phitter/web/views/registration_view.ex
defmodule Phitter.RegistrationView do
  use Phitter.Web, :view
end
#+END_SRC

*** Add Registration Form

#+BEGIN_SRC html
<!-- phitter/web/templates/registration/new.html.eex -->

<h3>Registration</h3>
<%= form_for @changeset, registration_path(@conn, :create), fn f -> %>
  <%= if f.errors != [] do %>
    <div class="alert alert-danger">
      <p>Oops, something went wrong! Please check the errors below:</p>
      <ul>
        <%= for {attr, message} <- f.errors do %>
          <li><%= humanize(attr) %> <%= message %></li>
        <% end %>
      </ul>
    </div>
  <% end %>
#+END_SRC
#+REVEAL: split
#+BEGIN_SRC html
  <div class="form-group">
    <label>Username</label>
    <%= text_input f, :username, class: "form-control" %>
  </div>

  <div class="form-group">
    <label>Password</label>
    <%= password_input f, :password, class: "form-control" %>
  </div>
#+END_SRC
#+REVEAL: split
#+BEGIN_SRC html
  <div class="form-group">
    <label>Password Confirmation</label>
    <%= password_input f, :password_confirmation, class: "form-control" %>
  </div>

  <div class="form-group">
    <%= submit "Register", class: "btn btn-primary" %>
    <%####= link("Login", to: session_path(@conn, :new), class: "btn btn-success pull-right") %>
  </div>
<% end %>
#+END_SRC

*** Add Registration to Routes

#+BEGIN_SRC elixir
# phitter/web/router.ex

scope "/", Phitter do
  pipe_through :browser # Use the default browser stack
  get "/registration", RegistrationController, :new      # <== NEW
  post "/registration", RegistrationController, :create  # <== NEW

  get "/", PageController, :index
end
#+END_SRC

    [[http://localhost:4000/registration]]

*** Add Registration Create Action

  - Add =comeonin= package for encryption

  - Create the user and store their ecto model in the session if all their
    validations pass or it will render the =new= action if the validation
    fails.

*** Add comeonin encryption package

#+BEGIN_SRC elixir
## phitter/mix.exs
##....
  defp deps do
    [{:phoenix, "~> 0.14"},
     {:phoenix_ecto, "~> 0.4"},
     {:postgrex, ">= 0.0.0"},
     {:phoenix_html, "~> 1.1"},
     {:phoenix_live_reload, "~> 0.4", only: :dev},
     {:cowboy, "~> 1.0"},
     {:comeonin, "~> 0.11.3"}]    # <== NEW
  end
end
#+END_SRC

*** Considerations on Implementing Password

  - Splitting out password encryption into separate module
  - Prevent =User= model bloat
  - Reuse password handling if more than one registration point

*** Implement Password Handling

#+BEGIN_SRC elixir
# phitter/lib/phitter/password.ex

defmodule Phitter.Password do
  alias Phitter.Repo
  import Ecto.Changeset, only: [put_change: 3]   # <== NOTE IMPORTED METHOD
  import Comeonin.Bcrypt, only: [hashpwsalt: 1]  # <== DITTO!

  @doc """
    Generates a password for the user changeset and stores it to the changeset as encrypted_password.
  """

  def generate_password(changeset) do
    put_change(changeset, :encrypted_password, hashpwsalt(changeset.params["password"]))
  end

  @doc """
    Generates the password for the changeset and then stores it to the database.
  """
  def generate_password_and_store_user(changeset) do
    changeset
      |> generate_password
      |> Repo.insert
  end
end
#+END_SRC

*** Implement Create Action -- Add Alias

#+BEGIN_SRC elixir
# phitter/web/controllers/registration_controller.ex

defmodule Phitter.RegistrationController do
  use Phitter.Web, :controller
  plug :scrub_params, "user" when action in [:create]
  alias Phitter.Password    # <== ALIAS TO WHAT WE JUST CREATED
# ...
#+END_SRC

*** Implement Create Action -- Create User

#+BEGIN_SRC elixir
  #...
  def create(conn, %{"user" => user_params}) do
    changeset = User.changeset(%User{}, user_params)
    if changeset.valid? do
      new_user = Password.generate_password_and_store_user(changeset)

      conn
        |> put_flash(:info, "Successfully registered and logged in")
        |> put_session(:current_user, new_user)
        |> redirect(to: page_path(conn, :index))
    else
      render conn, "new.html", changeset: changeset
    end
  end
end
#+END_SRC

*** Test Registration Form

This finishes our =RegistrationController=.

  - We can visit the registration form and test it now.

  - After you create a user it should redirect
    to the pages index page with a flash message letting you
    know that you've logged in.

*** Create SessionController and SessionView

Now that we can sign up let's go ahead and make it where we can sign in.

  - ake the session controller with 3 actions:

    - =new/2=
    - =create/2=
    - =delete/2=

  - First create a view for our =SessionController=.

*** Add SessionView

#+BEGIN_SRC elixir
# phitter/web/views/session_view.ex

defmodule Phitter.SessionView do
  use Phitter.Web, :view
end
#+END_SRC

*** Add SessionController
#+BEGIN_SRC elixir
# phitter/web/controllers/session_controller.ex

defmodule Phitter.SessionController do
  use Phitter.Web, :controller

  plug :scrub_params, "user" when action in [:create]

  def new(conn, _params) do
    render conn, changeset: User.changeset(%User{})
  end

  def create(conn, %{"user" => user_params}) do
    user = if is_nil(user_params["username"]) do
      nil
    else
      Repo.get_by(User, username: user_params["username"])
    end

    user
      |> sign_in(user_params["password"], conn)
  end
#+END_SRC
#+REVEAL: split
#+BEGIN_SRC elixir

  def delete(conn, _) do
    delete_session(conn, :current_user)
      |> put_flash(:info, 'You have been logged out')
      |> redirect(to: session_path(conn, :new))
  end

  defp sign_in(user, password, conn) when is_nil(user) do
    conn
      |> put_flash(:error, 'Could not find a user with that username.')
      |> render "new.html", changeset: User.changeset(%User{})
  end
#+END_SRC
#+REVEAL: split
#+BEGIN_SRC elixir

  defp sign_in(user, password, conn) when is_map(user) do
    cond do
      Comeonin.Bcrypt.checkpw(password, user.encrypted_password) ->
        conn
          |> put_session(:current_user, user)
          |> put_flash(:info, 'You are now signed in.')
          |> redirect(to: page_path(conn, :index))
      true ->
        conn
          |> put_flash(:error, 'Username or password are incorrect.')
          |> render "new.html", changeset: User.changeset(%User{})
    end
  end
end

#+END_SRC

*** Update Routes with Session

#+BEGIN_SRC elixir
#phitter/web/router.ex

#...

scope "/", Phitter do
  pipe_through :browser # Use the default browser stack

  get "/", SessionController, :new
  post "/login", SessionController, :create
  get "/logout", SessionController, :delete
  get "/registration", RegistrationController, :new # <== NEW?
  post "/registration", RegistrationController, :create # <== NEW?

  get "/pages", PageController, :index
end

#+END_SRC

*** Add Session Template

#+BEGIN_SRC html
<!-- web/templates/session/new.html.eex -->
<h3>Login</h3>
<%= form_for @changeset, session_path(@conn, :create), fn f -> %>
  <%= if f.errors != [] do %>
    <div class="alert alert-danger">
      <p>Oops, something went wrong! Please check the errors below:</p>
      <ul>
        <%= for {attr, message} <- f.errors do %>
          <li><%= humanize(attr) %> <%= message %></li>
        <% end %>
      </ul>
    </div>
  <% end %>
#+END_SRC
#+REVEAL: split
#+BEGIN_SRC html
  <div class="form-group">
    <label>Username</label>
    <%= text_input f, :username, class: "form-control" %>
  </div>

  <div class="form-group">
    <label>Password</label>
    <%= password_input f, :password, class: "form-control" %>
  </div>

  <div class="form-group">
    <%= submit "Login", class: "btn btn-primary" %>
    <%= link("Sign Up", to: registration_path(@conn, :new), class: "btn btn-success pull-right") %>
  </div>
<% end %>

#+END_SRC

*** Next Steps

  1. Uncomment the session link in our form at
     =phitter/web/templates/registrations/new.html.eex=.

  1. Here the =sign_in= function will check if
     the user is nil or it will try to log in the user if the map
     is given from =Repo.get/2=. The =cond= condition looks odd
     but basically it's checking the password submitted by the
     user and if that is true it will log in. If that doesn't work then
     it will default the the =true ->= value and tell the person
     they can't login with that username and password combination.

  1. We then store the user model to the session like we did
     in the =RegistrationController= so we can access the user
     in with the =current_user= value in the session. We're
     redirecting to the page's controller for now but once
     we implement the Pheet controller and model then all
     this will work together a little better. With that, let's do it!

*** Creating the Pheet model

#+BEGIN_SRC bash
mix phoenix.gen.html Pheet pheets body
#+END_SRC

generates the following on the console:

#+BEGIN_SRC
  mix phoenix.gen.html Pheet pheets body
  Generated phitter app
  * creating priv/repo/migrations/20150728052939_create_pheet.exs
  * creating web/models/pheet.ex
  * creating test/models/pheet_test.exs
  * creating web/controllers/pheet_controller.ex
  * creating web/templates/pheet/edit.html.eex
  * creating web/templates/pheet/form.html.eex
  * creating web/templates/pheet/index.html.eex
  * creating web/templates/pheet/new.html.eex
  * creating web/templates/pheet/show.html.eex
  * creating web/views/pheet_view.ex
  * creating test/controllers/pheet_controller_test.exs

  Add the resource to your browser scope in web/router.ex:

    resources "/pheets", PheetController

  and then update your repository by running migrations:

    $ mix ecto.migrate
#+END_SRC

*** Relate User and Pheet

#+BEGIN_SRC elixir
### phitter/priv/repo/migrations/create_pheet.exs
defmodule Phitter.Repo.Migrations.CreatePheet do
  use Ecto.Migration

  def change do
    create table(:pheets) do
      add :body, :string
      add :user_id, references(:users)  # <== ADDED
      timestamps
    end
    create index(:pheets, [:user_id])   # <== ADDED
  end
end
#+END_SRC

*** Migrate Database

We've just added the =:user_id= reference column. Now migrate your database.

/TODO: Include the migration command/

Now let's edit the models now. I'm not going to add

#+REVEAL: split
Edit User Model

#+BEGIN_SRC elixir
# phitter/web/models/user.ex

#...
schema "users" do
  has_many :pheets, Phitter.Pheet
  field :username, :string
  field :encrypted_password, :string
  field :password, :string, virtual: true
  field :password_confirmation, :string, virtual: true
  timestamps
end
#...
#+END_SRC

#+REVEAL: split
Edit Pheet Model

#+BEGIN_SRC elixir
# phitter/web/models/pheet.ex

defmodule Phitter.Pheet do
  use Phitter.Web, :model

  schema "pheets" do
    belongs_to :user, Phitter.User
    field :body, :string

    timestamps
  end

  @required_fields ~w(body user_id)
  @optional_fields ~w()
#+END_SRC
#+REVEAL: split
#+BEGIN_SRC elixir
  @doc """
  Creates a changeset based on the =model= and =params=.

  If =params= are nil, an invalid changeset is returned
  with no validation performed.
  """
  def changeset(model, params \\ nil) do
    model
    |> cast(params, @required_fields, @optional_fields)
  end
end
#+END_SRC

#+REVEAL: split
Add Pheet Controllers and Views

We've added the relationship between user and pheet.
We've got =user_id= and =body= in the required_fields so
that they'll throw errors if they are nil.

*(If you haven't noticed by now.
The =required_fields= is basically validating presence true in
Rails ActiveRecord validations)*

Now that we have that let's add our controllers and views for Pheets

Now that we need to start authenticating users we'll create a plug
to allow us to authenticate users on each request.
If the user is authenticated it'll move on to the action,
if not then it will redirect them to the login page.
Creating a plug was easier than I thought.
Thanks to [addict][] package for some tips on how to do this.

#+REVEAL: split
Authentication Plug

#+BEGIN_SRC elixir
defmodule Phitter.Plug.Authenticate do
  import Plug.Conn
  import Phitter.Router.Helpers
  import Phoenix.Controller

  def init(default), do: default

  def call(conn, default) do
    current_user = get_session(conn, :current_user)
    if current_user do
      assign(conn, :current_user, current_user)
    else
      conn
        |> put_flash(:error, 'You need to be signed in to view this page')
        |> redirect(to: session_path(conn, :new))
    end
  end
end
#+END_SRC

#+REVEAL: split
Creating Pheet Controller

The controller is pretty simple. To make this app easy you'll only be allowed
to create Pheets. This way we'll only need 3 actions

  1. =index/2=
  1. =new/2=
  1. =create/2=

We'll also play around with Ecto.Query.
Specifically the =preload= and =order_by= functions. Take a look:

#+REVEAL: split
Pheet Controller
#+BEGIN_SRC elixir
defmodule Phitter.PheetController do
  use Phitter.Web, :controller

  alias Phitter.Pheet

  plug Phitter.Plug.Authenticate
  plug :scrub_params, "pheet" when action in [:create, :update]
  plug :action

  def index(conn, _params) do
    pheets = Repo.all from p in Pheet,
      order_by: [desc: p.updated_at],
      preload: [:user]

    render(conn, "index.html", pheets: pheets)
  end

  def new(conn, _params) do
    changeset = Pheet.changeset(%Pheet{})
    render(conn, "new.html", changeset: changeset)
  end
#+END_SRC
#+REVEAL: split
  def create(conn, %{"pheet" => pheet_params}) do
    new_pheet = build(conn.assigns.current_user, :pheets)
    changeset = Pheet.changeset(new_pheet, pheet_params)

    if changeset.valid? do
      Repo.insert(changeset)

      conn
      |> put_flash(:info, "Pheet created successfully.")
      |> redirect(to: pheet_path(conn, :index))
    else
      render(conn, "new.html", changeset: changeset)
    end
  end
end
#+END_SRC

#+REVEAL: split
Pheet View

Now I'll let you go ahead and create your =PheetView= and I'll post the
views below. *(I need to find out how to make it default to a
ApplicationView if you don't need one. I feel odd just creating blank
view modules. Feel free to comment if you know anything about that.)*

*** Pheet new.html.eex, form.html.eex, index.html.eex
The templates are pretty simple. Just add the user to the index and we're good.

*** =new.html.eex=

#+BEGIN_SRC html
<h2>New pheet</h2>

<%= render "form.html", changeset: @changeset,
                        action: pheet_path(@conn, :create) %>

<%= link "Back", to: pheet_path(@conn, :index) %>
#+END_SRC

*** =form.html.eex=

#+BEGIN_SRC html
<%= form_for @changeset, @action, fn f -> %>
  <%= if f.errors != [] do %>
    <div class="alert alert-danger">
      <p>Oops, something went wrong! Please check the errors below:</p>
      <ul>
        <%= for {attr, message} <- f.errors do %>
          <li><%= humanize(attr) %> <%= message %></li>
        <% end %>
      </ul>
    </div>
  <% end %>

  <div class="form-group">
    <label>Body</label>
    <%= text_input f, :body, class: "form-control" %>
  </div>

  <div class="form-group">
    <%= submit "Submit", class: "btn btn-primary" %>
  </div>
<% end %>

#+END_SRC

#+REVEAL: split
index.html.eex

#+BEGIN_SRC html
<div>
  Hello, <%= @current_user.username %> <%= link "Logout", to: session_path(@conn, :delete) %>
</div>

<div class="text-center">
  <%= link "New pheet", to: pheet_path(@conn, :new), class: "btn btn-primary " %>
</div>

<div id="pheets-wrapper">
  <%= for pheet <- @pheets do %>
      <div class="pheet">
        <div class="pheet-author">
          <%= pheet.body %>
        </div>
        <div class="pheet-author">
          - <%= pheet.user.username %>
        </div>
      </div>
  <% end %>
</div>

#+END_SRC

* The End!

Well there we have it. It wasn't so bad was it? Let me know what you think in the commments! Thank you so much for taking the time to read this and I hope you've learned something!
* Play Area

Nice org mode commands from Forrest.  Just type them as /less-than/ then one of:

  - 's' for code blocks ("source" code)
  - 'q' for quote
  - 'h' for html block

#+BEGIN_QUOTE
Everything should be made as simple as possible,
     but not any simpler -- Albert Einstein
#+END_QUOTE
And let's see what that does.
#+BEGIN_HTML
<h3>A header</h3>
<p>Here is a paragraph</p>
#+END_HTML
#+REVEAL: split
#+BEGIN_SRC ruby
def bun
  # do something
end
#+END_SRC
